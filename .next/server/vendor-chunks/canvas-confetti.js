"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvas-confetti";
exports.ids = ["vendor-chunks/canvas-confetti"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvas-confetti/dist/confetti.module.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/canvas-confetti/dist/confetti.module.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// canvas-confetti v1.9.4 built on 2025-10-25T05:14:56.640Z\nvar module = {};\n// source content\n/* globals Map */ (function main(global, module, isWorker, workerSize) {\n    var canUseWorker = !!(global.Worker && global.Blob && global.Promise && global.OffscreenCanvas && global.OffscreenCanvasRenderingContext2D && global.HTMLCanvasElement && global.HTMLCanvasElement.prototype.transferControlToOffscreen && global.URL && global.URL.createObjectURL);\n    var canUsePaths = typeof Path2D === \"function\" && typeof DOMMatrix === \"function\";\n    var canDrawBitmap = function() {\n        // this mostly supports ssr\n        if (!global.OffscreenCanvas) {\n            return false;\n        }\n        try {\n            var canvas = new OffscreenCanvas(1, 1);\n            var ctx = canvas.getContext(\"2d\");\n            ctx.fillRect(0, 0, 1, 1);\n            var bitmap = canvas.transferToImageBitmap();\n            ctx.createPattern(bitmap, \"no-repeat\");\n        } catch (e) {\n            return false;\n        }\n        return true;\n    }();\n    function noop() {}\n    // create a promise if it exists, otherwise, just\n    // call the function directly\n    function promise(func) {\n        var ModulePromise = module.exports.Promise;\n        var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;\n        if (typeof Prom === \"function\") {\n            return new Prom(func);\n        }\n        func(noop, noop);\n        return null;\n    }\n    var bitmapMapper = function(skipTransform, map) {\n        // see https://github.com/catdad/canvas-confetti/issues/209\n        // creating canvases is actually pretty expensive, so we should create a\n        // 1:1 map for bitmap:canvas, so that we can animate the confetti in\n        // a performant manner, but also not store them forever so that we don't\n        // have a memory leak\n        return {\n            transform: function(bitmap) {\n                if (skipTransform) {\n                    return bitmap;\n                }\n                if (map.has(bitmap)) {\n                    return map.get(bitmap);\n                }\n                var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n                var ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(bitmap, 0, 0);\n                map.set(bitmap, canvas);\n                return canvas;\n            },\n            clear: function() {\n                map.clear();\n            }\n        };\n    }(canDrawBitmap, new Map());\n    var raf = function() {\n        var TIME = Math.floor(1000 / 60);\n        var frame, cancel;\n        var frames = {};\n        var lastFrameTime = 0;\n        if (typeof requestAnimationFrame === \"function\" && typeof cancelAnimationFrame === \"function\") {\n            frame = function(cb) {\n                var id = Math.random();\n                frames[id] = requestAnimationFrame(function onFrame(time) {\n                    if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {\n                        lastFrameTime = time;\n                        delete frames[id];\n                        cb();\n                    } else {\n                        frames[id] = requestAnimationFrame(onFrame);\n                    }\n                });\n                return id;\n            };\n            cancel = function(id) {\n                if (frames[id]) {\n                    cancelAnimationFrame(frames[id]);\n                }\n            };\n        } else {\n            frame = function(cb) {\n                return setTimeout(cb, TIME);\n            };\n            cancel = function(timer) {\n                return clearTimeout(timer);\n            };\n        }\n        return {\n            frame: frame,\n            cancel: cancel\n        };\n    }();\n    var getWorker = function() {\n        var worker;\n        var prom;\n        var resolves = {};\n        function decorate(worker) {\n            function execute(options, callback) {\n                worker.postMessage({\n                    options: options || {},\n                    callback: callback\n                });\n            }\n            worker.init = function initWorker(canvas) {\n                var offscreen = canvas.transferControlToOffscreen();\n                worker.postMessage({\n                    canvas: offscreen\n                }, [\n                    offscreen\n                ]);\n            };\n            worker.fire = function fireWorker(options, size, done) {\n                if (prom) {\n                    execute(options, null);\n                    return prom;\n                }\n                var id = Math.random().toString(36).slice(2);\n                prom = promise(function(resolve) {\n                    function workerDone(msg) {\n                        if (msg.data.callback !== id) {\n                            return;\n                        }\n                        delete resolves[id];\n                        worker.removeEventListener(\"message\", workerDone);\n                        prom = null;\n                        bitmapMapper.clear();\n                        done();\n                        resolve();\n                    }\n                    worker.addEventListener(\"message\", workerDone);\n                    execute(options, id);\n                    resolves[id] = workerDone.bind(null, {\n                        data: {\n                            callback: id\n                        }\n                    });\n                });\n                return prom;\n            };\n            worker.reset = function resetWorker() {\n                worker.postMessage({\n                    reset: true\n                });\n                for(var id in resolves){\n                    resolves[id]();\n                    delete resolves[id];\n                }\n            };\n        }\n        return function() {\n            if (worker) {\n                return worker;\n            }\n            if (!isWorker && canUseWorker) {\n                var code = [\n                    \"var CONFETTI, SIZE = {}, module = {};\",\n                    \"(\" + main.toString() + \")(this, module, true, SIZE);\",\n                    \"onmessage = function(msg) {\",\n                    \"  if (msg.data.options) {\",\n                    \"    CONFETTI(msg.data.options).then(function () {\",\n                    \"      if (msg.data.callback) {\",\n                    \"        postMessage({ callback: msg.data.callback });\",\n                    \"      }\",\n                    \"    });\",\n                    \"  } else if (msg.data.reset) {\",\n                    \"    CONFETTI && CONFETTI.reset();\",\n                    \"  } else if (msg.data.resize) {\",\n                    \"    SIZE.width = msg.data.resize.width;\",\n                    \"    SIZE.height = msg.data.resize.height;\",\n                    \"  } else if (msg.data.canvas) {\",\n                    \"    SIZE.width = msg.data.canvas.width;\",\n                    \"    SIZE.height = msg.data.canvas.height;\",\n                    \"    CONFETTI = module.exports.create(msg.data.canvas);\",\n                    \"  }\",\n                    \"}\"\n                ].join(\"\\n\");\n                try {\n                    worker = new Worker(URL.createObjectURL(new Blob([\n                        code\n                    ])));\n                } catch (e) {\n                    // eslint-disable-next-line no-console\n                    typeof console !== \"undefined\" && typeof console.warn === \"function\" ? console.warn(\"\\uD83C\\uDF8A Could not load worker\", e) : null;\n                    return null;\n                }\n                decorate(worker);\n            }\n            return worker;\n        };\n    }();\n    var defaults = {\n        particleCount: 50,\n        angle: 90,\n        spread: 45,\n        startVelocity: 45,\n        decay: 0.9,\n        gravity: 1,\n        drift: 0,\n        ticks: 200,\n        x: 0.5,\n        y: 0.5,\n        shapes: [\n            \"square\",\n            \"circle\"\n        ],\n        zIndex: 100,\n        colors: [\n            \"#26ccff\",\n            \"#a25afd\",\n            \"#ff5e7e\",\n            \"#88ff5a\",\n            \"#fcff42\",\n            \"#ffa62d\",\n            \"#ff36ff\"\n        ],\n        // probably should be true, but back-compat\n        disableForReducedMotion: false,\n        scalar: 1\n    };\n    function convert(val, transform) {\n        return transform ? transform(val) : val;\n    }\n    function isOk(val) {\n        return !(val === null || val === undefined);\n    }\n    function prop(options, name, transform) {\n        return convert(options && isOk(options[name]) ? options[name] : defaults[name], transform);\n    }\n    function onlyPositiveInt(number) {\n        return number < 0 ? 0 : Math.floor(number);\n    }\n    function randomInt(min, max) {\n        // [min, max)\n        return Math.floor(Math.random() * (max - min)) + min;\n    }\n    function toDecimal(str) {\n        return parseInt(str, 16);\n    }\n    function colorsToRgb(colors) {\n        return colors.map(hexToRgb);\n    }\n    function hexToRgb(str) {\n        var val = String(str).replace(/[^0-9a-f]/gi, \"\");\n        if (val.length < 6) {\n            val = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];\n        }\n        return {\n            r: toDecimal(val.substring(0, 2)),\n            g: toDecimal(val.substring(2, 4)),\n            b: toDecimal(val.substring(4, 6))\n        };\n    }\n    function getOrigin(options) {\n        var origin = prop(options, \"origin\", Object);\n        origin.x = prop(origin, \"x\", Number);\n        origin.y = prop(origin, \"y\", Number);\n        return origin;\n    }\n    function setCanvasWindowSize(canvas) {\n        canvas.width = document.documentElement.clientWidth;\n        canvas.height = document.documentElement.clientHeight;\n    }\n    function setCanvasRectSize(canvas) {\n        var rect = canvas.getBoundingClientRect();\n        canvas.width = rect.width;\n        canvas.height = rect.height;\n    }\n    function getCanvas(zIndex) {\n        var canvas = document.createElement(\"canvas\");\n        canvas.style.position = \"fixed\";\n        canvas.style.top = \"0px\";\n        canvas.style.left = \"0px\";\n        canvas.style.pointerEvents = \"none\";\n        canvas.style.zIndex = zIndex;\n        return canvas;\n    }\n    function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\n        context.save();\n        context.translate(x, y);\n        context.rotate(rotation);\n        context.scale(radiusX, radiusY);\n        context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\n        context.restore();\n    }\n    function randomPhysics(opts) {\n        var radAngle = opts.angle * (Math.PI / 180);\n        var radSpread = opts.spread * (Math.PI / 180);\n        return {\n            x: opts.x,\n            y: opts.y,\n            wobble: Math.random() * 10,\n            wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),\n            velocity: opts.startVelocity * 0.5 + Math.random() * opts.startVelocity,\n            angle2D: -radAngle + (0.5 * radSpread - Math.random() * radSpread),\n            tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,\n            color: opts.color,\n            shape: opts.shape,\n            tick: 0,\n            totalTicks: opts.ticks,\n            decay: opts.decay,\n            drift: opts.drift,\n            random: Math.random() + 2,\n            tiltSin: 0,\n            tiltCos: 0,\n            wobbleX: 0,\n            wobbleY: 0,\n            gravity: opts.gravity * 3,\n            ovalScalar: 0.6,\n            scalar: opts.scalar,\n            flat: opts.flat\n        };\n    }\n    function updateFetti(context, fetti) {\n        fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;\n        fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;\n        fetti.velocity *= fetti.decay;\n        if (fetti.flat) {\n            fetti.wobble = 0;\n            fetti.wobbleX = fetti.x + 10 * fetti.scalar;\n            fetti.wobbleY = fetti.y + 10 * fetti.scalar;\n            fetti.tiltSin = 0;\n            fetti.tiltCos = 0;\n            fetti.random = 1;\n        } else {\n            fetti.wobble += fetti.wobbleSpeed;\n            fetti.wobbleX = fetti.x + 10 * fetti.scalar * Math.cos(fetti.wobble);\n            fetti.wobbleY = fetti.y + 10 * fetti.scalar * Math.sin(fetti.wobble);\n            fetti.tiltAngle += 0.1;\n            fetti.tiltSin = Math.sin(fetti.tiltAngle);\n            fetti.tiltCos = Math.cos(fetti.tiltAngle);\n            fetti.random = Math.random() + 2;\n        }\n        var progress = fetti.tick++ / fetti.totalTicks;\n        var x1 = fetti.x + fetti.random * fetti.tiltCos;\n        var y1 = fetti.y + fetti.random * fetti.tiltSin;\n        var x2 = fetti.wobbleX + fetti.random * fetti.tiltCos;\n        var y2 = fetti.wobbleY + fetti.random * fetti.tiltSin;\n        context.fillStyle = \"rgba(\" + fetti.color.r + \", \" + fetti.color.g + \", \" + fetti.color.b + \", \" + (1 - progress) + \")\";\n        context.beginPath();\n        if (canUsePaths && fetti.shape.type === \"path\" && typeof fetti.shape.path === \"string\" && Array.isArray(fetti.shape.matrix)) {\n            context.fill(transformPath2D(fetti.shape.path, fetti.shape.matrix, fetti.x, fetti.y, Math.abs(x2 - x1) * 0.1, Math.abs(y2 - y1) * 0.1, Math.PI / 10 * fetti.wobble));\n        } else if (fetti.shape.type === \"bitmap\") {\n            var rotation = Math.PI / 10 * fetti.wobble;\n            var scaleX = Math.abs(x2 - x1) * 0.1;\n            var scaleY = Math.abs(y2 - y1) * 0.1;\n            var width = fetti.shape.bitmap.width * fetti.scalar;\n            var height = fetti.shape.bitmap.height * fetti.scalar;\n            var matrix = new DOMMatrix([\n                Math.cos(rotation) * scaleX,\n                Math.sin(rotation) * scaleX,\n                -Math.sin(rotation) * scaleY,\n                Math.cos(rotation) * scaleY,\n                fetti.x,\n                fetti.y\n            ]);\n            // apply the transform matrix from the confetti shape\n            matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));\n            var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), \"no-repeat\");\n            pattern.setTransform(matrix);\n            context.globalAlpha = 1 - progress;\n            context.fillStyle = pattern;\n            context.fillRect(fetti.x - width / 2, fetti.y - height / 2, width, height);\n            context.globalAlpha = 1;\n        } else if (fetti.shape === \"circle\") {\n            context.ellipse ? context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) : ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);\n        } else if (fetti.shape === \"star\") {\n            var rot = Math.PI / 2 * 3;\n            var innerRadius = 4 * fetti.scalar;\n            var outerRadius = 8 * fetti.scalar;\n            var x = fetti.x;\n            var y = fetti.y;\n            var spikes = 5;\n            var step = Math.PI / spikes;\n            while(spikes--){\n                x = fetti.x + Math.cos(rot) * outerRadius;\n                y = fetti.y + Math.sin(rot) * outerRadius;\n                context.lineTo(x, y);\n                rot += step;\n                x = fetti.x + Math.cos(rot) * innerRadius;\n                y = fetti.y + Math.sin(rot) * innerRadius;\n                context.lineTo(x, y);\n                rot += step;\n            }\n        } else {\n            context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));\n            context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));\n            context.lineTo(Math.floor(x2), Math.floor(y2));\n            context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));\n        }\n        context.closePath();\n        context.fill();\n        return fetti.tick < fetti.totalTicks;\n    }\n    function animate(canvas, fettis, resizer, size, done) {\n        var animatingFettis = fettis.slice();\n        var context = canvas.getContext(\"2d\");\n        var animationFrame;\n        var destroy;\n        var prom = promise(function(resolve) {\n            function onDone() {\n                animationFrame = destroy = null;\n                context.clearRect(0, 0, size.width, size.height);\n                bitmapMapper.clear();\n                done();\n                resolve();\n            }\n            function update() {\n                if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {\n                    size.width = canvas.width = workerSize.width;\n                    size.height = canvas.height = workerSize.height;\n                }\n                if (!size.width && !size.height) {\n                    resizer(canvas);\n                    size.width = canvas.width;\n                    size.height = canvas.height;\n                }\n                context.clearRect(0, 0, size.width, size.height);\n                animatingFettis = animatingFettis.filter(function(fetti) {\n                    return updateFetti(context, fetti);\n                });\n                if (animatingFettis.length) {\n                    animationFrame = raf.frame(update);\n                } else {\n                    onDone();\n                }\n            }\n            animationFrame = raf.frame(update);\n            destroy = onDone;\n        });\n        return {\n            addFettis: function(fettis) {\n                animatingFettis = animatingFettis.concat(fettis);\n                return prom;\n            },\n            canvas: canvas,\n            promise: prom,\n            reset: function() {\n                if (animationFrame) {\n                    raf.cancel(animationFrame);\n                }\n                if (destroy) {\n                    destroy();\n                }\n            }\n        };\n    }\n    function confettiCannon(canvas, globalOpts) {\n        var isLibCanvas = !canvas;\n        var allowResize = !!prop(globalOpts || {}, \"resize\");\n        var hasResizeEventRegistered = false;\n        var globalDisableForReducedMotion = prop(globalOpts, \"disableForReducedMotion\", Boolean);\n        var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, \"useWorker\");\n        var worker = shouldUseWorker ? getWorker() : null;\n        var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;\n        var initialized = canvas && worker ? !!canvas.__confetti_initialized : false;\n        var preferLessMotion = typeof matchMedia === \"function\" && matchMedia(\"(prefers-reduced-motion)\").matches;\n        var animationObj;\n        function fireLocal(options, size, done) {\n            var particleCount = prop(options, \"particleCount\", onlyPositiveInt);\n            var angle = prop(options, \"angle\", Number);\n            var spread = prop(options, \"spread\", Number);\n            var startVelocity = prop(options, \"startVelocity\", Number);\n            var decay = prop(options, \"decay\", Number);\n            var gravity = prop(options, \"gravity\", Number);\n            var drift = prop(options, \"drift\", Number);\n            var colors = prop(options, \"colors\", colorsToRgb);\n            var ticks = prop(options, \"ticks\", Number);\n            var shapes = prop(options, \"shapes\");\n            var scalar = prop(options, \"scalar\");\n            var flat = !!prop(options, \"flat\");\n            var origin = getOrigin(options);\n            var temp = particleCount;\n            var fettis = [];\n            var startX = canvas.width * origin.x;\n            var startY = canvas.height * origin.y;\n            while(temp--){\n                fettis.push(randomPhysics({\n                    x: startX,\n                    y: startY,\n                    angle: angle,\n                    spread: spread,\n                    startVelocity: startVelocity,\n                    color: colors[temp % colors.length],\n                    shape: shapes[randomInt(0, shapes.length)],\n                    ticks: ticks,\n                    decay: decay,\n                    gravity: gravity,\n                    drift: drift,\n                    scalar: scalar,\n                    flat: flat\n                }));\n            }\n            // if we have a previous canvas already animating,\n            // add to it\n            if (animationObj) {\n                return animationObj.addFettis(fettis);\n            }\n            animationObj = animate(canvas, fettis, resizer, size, done);\n            return animationObj.promise;\n        }\n        function fire(options) {\n            var disableForReducedMotion = globalDisableForReducedMotion || prop(options, \"disableForReducedMotion\", Boolean);\n            var zIndex = prop(options, \"zIndex\", Number);\n            if (disableForReducedMotion && preferLessMotion) {\n                return promise(function(resolve) {\n                    resolve();\n                });\n            }\n            if (isLibCanvas && animationObj) {\n                // use existing canvas from in-progress animation\n                canvas = animationObj.canvas;\n            } else if (isLibCanvas && !canvas) {\n                // create and initialize a new canvas\n                canvas = getCanvas(zIndex);\n                document.body.appendChild(canvas);\n            }\n            if (allowResize && !initialized) {\n                // initialize the size of a user-supplied canvas\n                resizer(canvas);\n            }\n            var size = {\n                width: canvas.width,\n                height: canvas.height\n            };\n            if (worker && !initialized) {\n                worker.init(canvas);\n            }\n            initialized = true;\n            if (worker) {\n                canvas.__confetti_initialized = true;\n            }\n            function onResize() {\n                if (worker) {\n                    // TODO this really shouldn't be immediate, because it is expensive\n                    var obj = {\n                        getBoundingClientRect: function() {\n                            if (!isLibCanvas) {\n                                return canvas.getBoundingClientRect();\n                            }\n                        }\n                    };\n                    resizer(obj);\n                    worker.postMessage({\n                        resize: {\n                            width: obj.width,\n                            height: obj.height\n                        }\n                    });\n                    return;\n                }\n                // don't actually query the size here, since this\n                // can execute frequently and rapidly\n                size.width = size.height = null;\n            }\n            function done() {\n                animationObj = null;\n                if (allowResize) {\n                    hasResizeEventRegistered = false;\n                    global.removeEventListener(\"resize\", onResize);\n                }\n                if (isLibCanvas && canvas) {\n                    if (document.body.contains(canvas)) {\n                        document.body.removeChild(canvas);\n                    }\n                    canvas = null;\n                    initialized = false;\n                }\n            }\n            if (allowResize && !hasResizeEventRegistered) {\n                hasResizeEventRegistered = true;\n                global.addEventListener(\"resize\", onResize, false);\n            }\n            if (worker) {\n                return worker.fire(options, size, done);\n            }\n            return fireLocal(options, size, done);\n        }\n        fire.reset = function() {\n            if (worker) {\n                worker.reset();\n            }\n            if (animationObj) {\n                animationObj.reset();\n            }\n        };\n        return fire;\n    }\n    // Make default export lazy to defer worker creation until called.\n    var defaultFire;\n    function getDefaultFire() {\n        if (!defaultFire) {\n            defaultFire = confettiCannon(null, {\n                useWorker: true,\n                resize: true\n            });\n        }\n        return defaultFire;\n    }\n    function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {\n        var path2d = new Path2D(pathString);\n        var t1 = new Path2D();\n        t1.addPath(path2d, new DOMMatrix(pathMatrix));\n        var t2 = new Path2D();\n        // see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/DOMMatrix\n        t2.addPath(t1, new DOMMatrix([\n            Math.cos(rotation) * scaleX,\n            Math.sin(rotation) * scaleX,\n            -Math.sin(rotation) * scaleY,\n            Math.cos(rotation) * scaleY,\n            x,\n            y\n        ]));\n        return t2;\n    }\n    function shapeFromPath(pathData) {\n        if (!canUsePaths) {\n            throw new Error(\"path confetti are not supported in this browser\");\n        }\n        var path, matrix;\n        if (typeof pathData === \"string\") {\n            path = pathData;\n        } else {\n            path = pathData.path;\n            matrix = pathData.matrix;\n        }\n        var path2d = new Path2D(path);\n        var tempCanvas = document.createElement(\"canvas\");\n        var tempCtx = tempCanvas.getContext(\"2d\");\n        if (!matrix) {\n            // attempt to figure out the width of the path, up to 1000x1000\n            var maxSize = 1000;\n            var minX = maxSize;\n            var minY = maxSize;\n            var maxX = 0;\n            var maxY = 0;\n            var width, height;\n            // do some line skipping... this is faster than checking\n            // every pixel and will be mostly still correct\n            for(var x = 0; x < maxSize; x += 2){\n                for(var y = 0; y < maxSize; y += 2){\n                    if (tempCtx.isPointInPath(path2d, x, y, \"nonzero\")) {\n                        minX = Math.min(minX, x);\n                        minY = Math.min(minY, y);\n                        maxX = Math.max(maxX, x);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            }\n            width = maxX - minX;\n            height = maxY - minY;\n            var maxDesiredSize = 10;\n            var scale = Math.min(maxDesiredSize / width, maxDesiredSize / height);\n            matrix = [\n                scale,\n                0,\n                0,\n                scale,\n                -Math.round(width / 2 + minX) * scale,\n                -Math.round(height / 2 + minY) * scale\n            ];\n        }\n        return {\n            type: \"path\",\n            path: path,\n            matrix: matrix\n        };\n    }\n    function shapeFromText(textData) {\n        var text, scalar = 1, color = \"#000000\", // see https://nolanlawson.com/2022/04/08/the-struggle-of-using-native-emoji-on-the-web/\n        fontFamily = '\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\", \"EmojiOne Color\", \"Android Emoji\", \"Twemoji Mozilla\", \"system emoji\", sans-serif';\n        if (typeof textData === \"string\") {\n            text = textData;\n        } else {\n            text = textData.text;\n            scalar = \"scalar\" in textData ? textData.scalar : scalar;\n            fontFamily = \"fontFamily\" in textData ? textData.fontFamily : fontFamily;\n            color = \"color\" in textData ? textData.color : color;\n        }\n        // all other confetti are 10 pixels,\n        // so this pixel size is the de-facto 100% scale confetti\n        var fontSize = 10 * scalar;\n        var font = \"\" + fontSize + \"px \" + fontFamily;\n        var canvas = new OffscreenCanvas(fontSize, fontSize);\n        var ctx = canvas.getContext(\"2d\");\n        ctx.font = font;\n        var size = ctx.measureText(text);\n        var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);\n        var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);\n        var padding = 2;\n        var x = size.actualBoundingBoxLeft + padding;\n        var y = size.actualBoundingBoxAscent + padding;\n        width += padding + padding;\n        height += padding + padding;\n        canvas = new OffscreenCanvas(width, height);\n        ctx = canvas.getContext(\"2d\");\n        ctx.font = font;\n        ctx.fillStyle = color;\n        ctx.fillText(text, x, y);\n        var scale = 1 / scalar;\n        return {\n            type: \"bitmap\",\n            // TODO these probably need to be transfered for workers\n            bitmap: canvas.transferToImageBitmap(),\n            matrix: [\n                scale,\n                0,\n                0,\n                scale,\n                -width * scale / 2,\n                -height * scale / 2\n            ]\n        };\n    }\n    module.exports = function() {\n        return getDefaultFire().apply(this, arguments);\n    };\n    module.exports.reset = function() {\n        getDefaultFire().reset();\n    };\n    module.exports.create = confettiCannon;\n    module.exports.shapeFromPath = shapeFromPath;\n    module.exports.shapeFromText = shapeFromText;\n})(function() {\n    if (false) {}\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    return this || {};\n}(), module, false);\n// end source content\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);\nvar create = module.exports.create;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmFzLWNvbmZldHRpL2Rpc3QvY29uZmV0dGkubW9kdWxlLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJEQUEyRDtBQUMzRCxJQUFJQSxTQUFTLENBQUM7QUFFZCxpQkFBaUI7QUFDakIsZUFBZSxHQUVkLFVBQVNDLEtBQUtDLE1BQU0sRUFBRUYsTUFBTSxFQUFFRyxRQUFRLEVBQUVDLFVBQVU7SUFDakQsSUFBSUMsZUFBZSxDQUFDLENBQ2xCSCxDQUFBQSxPQUFPSSxNQUFNLElBQ2JKLE9BQU9LLElBQUksSUFDWEwsT0FBT00sT0FBTyxJQUNkTixPQUFPTyxlQUFlLElBQ3RCUCxPQUFPUSxpQ0FBaUMsSUFDeENSLE9BQU9TLGlCQUFpQixJQUN4QlQsT0FBT1MsaUJBQWlCLENBQUNDLFNBQVMsQ0FBQ0MsMEJBQTBCLElBQzdEWCxPQUFPWSxHQUFHLElBQ1ZaLE9BQU9ZLEdBQUcsQ0FBQ0MsZUFBZTtJQUU1QixJQUFJQyxjQUFjLE9BQU9DLFdBQVcsY0FBYyxPQUFPQyxjQUFjO0lBQ3ZFLElBQUlDLGdCQUFnQjtRQUNsQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDakIsT0FBT08sZUFBZSxFQUFFO1lBQzNCLE9BQU87UUFDVDtRQUVBLElBQUk7WUFDRixJQUFJVyxTQUFTLElBQUlYLGdCQUFnQixHQUFHO1lBQ3BDLElBQUlZLE1BQU1ELE9BQU9FLFVBQVUsQ0FBQztZQUM1QkQsSUFBSUUsUUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHO1lBQ3RCLElBQUlDLFNBQVNKLE9BQU9LLHFCQUFxQjtZQUN6Q0osSUFBSUssYUFBYSxDQUFDRixRQUFRO1FBQzVCLEVBQUUsT0FBT0csR0FBRztZQUNWLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVBLFNBQVNDLFFBQVE7SUFFakIsaURBQWlEO0lBQ2pELDZCQUE2QjtJQUM3QixTQUFTQyxRQUFRQyxJQUFJO1FBQ25CLElBQUlDLGdCQUFnQi9CLE9BQU9nQyxPQUFPLENBQUN4QixP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QU0sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpZnRsb2cvLi9ub2RlX21vZHVsZXMvY2FudmFzLWNvbmZldHRpL2Rpc3QvY29uZmV0dGkubW9kdWxlLm1qcz9mMWU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNhbnZhcy1jb25mZXR0aSB2MS45LjQgYnVpbHQgb24gMjAyNS0xMC0yNVQwNToxNDo1Ni42NDBaXG52YXIgbW9kdWxlID0ge307XG5cbi8vIHNvdXJjZSBjb250ZW50XG4vKiBnbG9iYWxzIE1hcCAqL1xuXG4oZnVuY3Rpb24gbWFpbihnbG9iYWwsIG1vZHVsZSwgaXNXb3JrZXIsIHdvcmtlclNpemUpIHtcbiAgdmFyIGNhblVzZVdvcmtlciA9ICEhKFxuICAgIGdsb2JhbC5Xb3JrZXIgJiZcbiAgICBnbG9iYWwuQmxvYiAmJlxuICAgIGdsb2JhbC5Qcm9taXNlICYmXG4gICAgZ2xvYmFsLk9mZnNjcmVlbkNhbnZhcyAmJlxuICAgIGdsb2JhbC5PZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgJiZcbiAgICBnbG9iYWwuSFRNTENhbnZhc0VsZW1lbnQgJiZcbiAgICBnbG9iYWwuSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLnRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuICYmXG4gICAgZ2xvYmFsLlVSTCAmJlxuICAgIGdsb2JhbC5VUkwuY3JlYXRlT2JqZWN0VVJMKTtcblxuICB2YXIgY2FuVXNlUGF0aHMgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBET01NYXRyaXggPT09ICdmdW5jdGlvbic7XG4gIHZhciBjYW5EcmF3Qml0bWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyB0aGlzIG1vc3RseSBzdXBwb3J0cyBzc3JcbiAgICBpZiAoIWdsb2JhbC5PZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICB2YXIgYml0bWFwID0gY2FudmFzLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgICAgY3R4LmNyZWF0ZVBhdHRlcm4oYml0bWFwLCAnbm8tcmVwZWF0Jyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gIC8vIGNyZWF0ZSBhIHByb21pc2UgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UsIGp1c3RcbiAgLy8gY2FsbCB0aGUgZnVuY3Rpb24gZGlyZWN0bHlcbiAgZnVuY3Rpb24gcHJvbWlzZShmdW5jKSB7XG4gICAgdmFyIE1vZHVsZVByb21pc2UgPSBtb2R1bGUuZXhwb3J0cy5Qcm9taXNlO1xuICAgIHZhciBQcm9tID0gTW9kdWxlUHJvbWlzZSAhPT0gdm9pZCAwID8gTW9kdWxlUHJvbWlzZSA6IGdsb2JhbC5Qcm9taXNlO1xuXG4gICAgaWYgKHR5cGVvZiBQcm9tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb20oZnVuYyk7XG4gICAgfVxuXG4gICAgZnVuYyhub29wLCBub29wKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGJpdG1hcE1hcHBlciA9IChmdW5jdGlvbiAoc2tpcFRyYW5zZm9ybSwgbWFwKSB7XG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRkYWQvY2FudmFzLWNvbmZldHRpL2lzc3Vlcy8yMDlcbiAgICAvLyBjcmVhdGluZyBjYW52YXNlcyBpcyBhY3R1YWxseSBwcmV0dHkgZXhwZW5zaXZlLCBzbyB3ZSBzaG91bGQgY3JlYXRlIGFcbiAgICAvLyAxOjEgbWFwIGZvciBiaXRtYXA6Y2FudmFzLCBzbyB0aGF0IHdlIGNhbiBhbmltYXRlIHRoZSBjb25mZXR0aSBpblxuICAgIC8vIGEgcGVyZm9ybWFudCBtYW5uZXIsIGJ1dCBhbHNvIG5vdCBzdG9yZSB0aGVtIGZvcmV2ZXIgc28gdGhhdCB3ZSBkb24ndFxuICAgIC8vIGhhdmUgYSBtZW1vcnkgbGVha1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKGJpdG1hcCkge1xuICAgICAgICBpZiAoc2tpcFRyYW5zZm9ybSkge1xuICAgICAgICAgIHJldHVybiBiaXRtYXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFwLmhhcyhiaXRtYXApKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcC5nZXQoYml0bWFwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCk7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xuXG4gICAgICAgIG1hcC5zZXQoYml0bWFwLCBjYW52YXMpO1xuXG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICB9LFxuICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWFwLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoY2FuRHJhd0JpdG1hcCwgbmV3IE1hcCgpKTtcblxuICB2YXIgcmFmID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgVElNRSA9IE1hdGguZmxvb3IoMTAwMCAvIDYwKTtcbiAgICB2YXIgZnJhbWUsIGNhbmNlbDtcbiAgICB2YXIgZnJhbWVzID0ge307XG4gICAgdmFyIGxhc3RGcmFtZVRpbWUgPSAwO1xuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmcmFtZSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgaWQgPSBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgIGZyYW1lc1tpZF0gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gb25GcmFtZSh0aW1lKSB7XG4gICAgICAgICAgaWYgKGxhc3RGcmFtZVRpbWUgPT09IHRpbWUgfHwgbGFzdEZyYW1lVGltZSArIFRJTUUgLSAxIDwgdGltZSkge1xuICAgICAgICAgICAgbGFzdEZyYW1lVGltZSA9IHRpbWU7XG4gICAgICAgICAgICBkZWxldGUgZnJhbWVzW2lkXTtcblxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhbWVzW2lkXSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH07XG4gICAgICBjYW5jZWwgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGZyYW1lc1tpZF0pIHtcbiAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZXNbaWRdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2IsIFRJTUUpO1xuICAgICAgfTtcbiAgICAgIGNhbmNlbCA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZnJhbWU6IGZyYW1lLCBjYW5jZWw6IGNhbmNlbCB9O1xuICB9KCkpO1xuXG4gIHZhciBnZXRXb3JrZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciB3b3JrZXI7XG4gICAgdmFyIHByb207XG4gICAgdmFyIHJlc29sdmVzID0ge307XG5cbiAgICBmdW5jdGlvbiBkZWNvcmF0ZSh3b3JrZXIpIHtcbiAgICAgIGZ1bmN0aW9uIGV4ZWN1dGUob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgb3B0aW9uczogb3B0aW9ucyB8fCB7fSwgY2FsbGJhY2s6IGNhbGxiYWNrIH0pO1xuICAgICAgfVxuICAgICAgd29ya2VyLmluaXQgPSBmdW5jdGlvbiBpbml0V29ya2VyKGNhbnZhcykge1xuICAgICAgICB2YXIgb2Zmc2NyZWVuID0gY2FudmFzLnRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuKCk7XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IGNhbnZhczogb2Zmc2NyZWVuIH0sIFtvZmZzY3JlZW5dKTtcbiAgICAgIH07XG5cbiAgICAgIHdvcmtlci5maXJlID0gZnVuY3Rpb24gZmlyZVdvcmtlcihvcHRpb25zLCBzaXplLCBkb25lKSB7XG4gICAgICAgIGlmIChwcm9tKSB7XG4gICAgICAgICAgZXhlY3V0ZShvcHRpb25zLCBudWxsKTtcbiAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4gICAgICAgIHByb20gPSBwcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgZnVuY3Rpb24gd29ya2VyRG9uZShtc2cpIHtcbiAgICAgICAgICAgIGlmIChtc2cuZGF0YS5jYWxsYmFjayAhPT0gaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgcmVzb2x2ZXNbaWRdO1xuICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB3b3JrZXJEb25lKTtcblxuICAgICAgICAgICAgcHJvbSA9IG51bGw7XG5cbiAgICAgICAgICAgIGJpdG1hcE1hcHBlci5jbGVhcigpO1xuXG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB3b3JrZXJEb25lKTtcbiAgICAgICAgICBleGVjdXRlKG9wdGlvbnMsIGlkKTtcblxuICAgICAgICAgIHJlc29sdmVzW2lkXSA9IHdvcmtlckRvbmUuYmluZChudWxsLCB7IGRhdGE6IHsgY2FsbGJhY2s6IGlkIH19KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHByb207XG4gICAgICB9O1xuXG4gICAgICB3b3JrZXIucmVzZXQgPSBmdW5jdGlvbiByZXNldFdvcmtlcigpIHtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgcmVzZXQ6IHRydWUgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gcmVzb2x2ZXMpIHtcbiAgICAgICAgICByZXNvbHZlc1tpZF0oKTtcbiAgICAgICAgICBkZWxldGUgcmVzb2x2ZXNbaWRdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNXb3JrZXIgJiYgY2FuVXNlV29ya2VyKSB7XG4gICAgICAgIHZhciBjb2RlID0gW1xuICAgICAgICAgICd2YXIgQ09ORkVUVEksIFNJWkUgPSB7fSwgbW9kdWxlID0ge307JyxcbiAgICAgICAgICAnKCcgKyBtYWluLnRvU3RyaW5nKCkgKyAnKSh0aGlzLCBtb2R1bGUsIHRydWUsIFNJWkUpOycsXG4gICAgICAgICAgJ29ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykgeycsXG4gICAgICAgICAgJyAgaWYgKG1zZy5kYXRhLm9wdGlvbnMpIHsnLFxuICAgICAgICAgICcgICAgQ09ORkVUVEkobXNnLmRhdGEub3B0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7JyxcbiAgICAgICAgICAnICAgICAgaWYgKG1zZy5kYXRhLmNhbGxiYWNrKSB7JyxcbiAgICAgICAgICAnICAgICAgICBwb3N0TWVzc2FnZSh7IGNhbGxiYWNrOiBtc2cuZGF0YS5jYWxsYmFjayB9KTsnLFxuICAgICAgICAgICcgICAgICB9JyxcbiAgICAgICAgICAnICAgIH0pOycsXG4gICAgICAgICAgJyAgfSBlbHNlIGlmIChtc2cuZGF0YS5yZXNldCkgeycsXG4gICAgICAgICAgJyAgICBDT05GRVRUSSAmJiBDT05GRVRUSS5yZXNldCgpOycsXG4gICAgICAgICAgJyAgfSBlbHNlIGlmIChtc2cuZGF0YS5yZXNpemUpIHsnLFxuICAgICAgICAgICcgICAgU0laRS53aWR0aCA9IG1zZy5kYXRhLnJlc2l6ZS53aWR0aDsnLFxuICAgICAgICAgICcgICAgU0laRS5oZWlnaHQgPSBtc2cuZGF0YS5yZXNpemUuaGVpZ2h0OycsXG4gICAgICAgICAgJyAgfSBlbHNlIGlmIChtc2cuZGF0YS5jYW52YXMpIHsnLFxuICAgICAgICAgICcgICAgU0laRS53aWR0aCA9IG1zZy5kYXRhLmNhbnZhcy53aWR0aDsnLFxuICAgICAgICAgICcgICAgU0laRS5oZWlnaHQgPSBtc2cuZGF0YS5jYW52YXMuaGVpZ2h0OycsXG4gICAgICAgICAgJyAgICBDT05GRVRUSSA9IG1vZHVsZS5leHBvcnRzLmNyZWF0ZShtc2cuZGF0YS5jYW52YXMpOycsXG4gICAgICAgICAgJyAgfScsXG4gICAgICAgICAgJ30nLFxuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdvcmtlciA9IG5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbY29kZV0pKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nID8gY29uc29sZS53YXJuKCfwn46KIENvdWxkIG5vdCBsb2FkIHdvcmtlcicsIGUpIDogbnVsbDtcblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGUod29ya2VyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9O1xuICB9KSgpO1xuXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBwYXJ0aWNsZUNvdW50OiA1MCxcbiAgICBhbmdsZTogOTAsXG4gICAgc3ByZWFkOiA0NSxcbiAgICBzdGFydFZlbG9jaXR5OiA0NSxcbiAgICBkZWNheTogMC45LFxuICAgIGdyYXZpdHk6IDEsXG4gICAgZHJpZnQ6IDAsXG4gICAgdGlja3M6IDIwMCxcbiAgICB4OiAwLjUsXG4gICAgeTogMC41LFxuICAgIHNoYXBlczogWydzcXVhcmUnLCAnY2lyY2xlJ10sXG4gICAgekluZGV4OiAxMDAsXG4gICAgY29sb3JzOiBbXG4gICAgICAnIzI2Y2NmZicsXG4gICAgICAnI2EyNWFmZCcsXG4gICAgICAnI2ZmNWU3ZScsXG4gICAgICAnIzg4ZmY1YScsXG4gICAgICAnI2ZjZmY0MicsXG4gICAgICAnI2ZmYTYyZCcsXG4gICAgICAnI2ZmMzZmZidcbiAgICBdLFxuICAgIC8vIHByb2JhYmx5IHNob3VsZCBiZSB0cnVlLCBidXQgYmFjay1jb21wYXRcbiAgICBkaXNhYmxlRm9yUmVkdWNlZE1vdGlvbjogZmFsc2UsXG4gICAgc2NhbGFyOiAxXG4gIH07XG5cbiAgZnVuY3Rpb24gY29udmVydCh2YWwsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0odmFsKSA6IHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2sodmFsKSB7XG4gICAgcmV0dXJuICEodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3Aob3B0aW9ucywgbmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGNvbnZlcnQoXG4gICAgICBvcHRpb25zICYmIGlzT2sob3B0aW9uc1tuYW1lXSkgPyBvcHRpb25zW25hbWVdIDogZGVmYXVsdHNbbmFtZV0sXG4gICAgICB0cmFuc2Zvcm1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25seVBvc2l0aXZlSW50KG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciA8IDAgPyAwIDogTWF0aC5mbG9vcihudW1iZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFuZG9tSW50KG1pbiwgbWF4KSB7XG4gICAgLy8gW21pbiwgbWF4KVxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSkgKyBtaW47XG4gIH1cblxuICBmdW5jdGlvbiB0b0RlY2ltYWwoc3RyKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTYpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29sb3JzVG9SZ2IoY29sb3JzKSB7XG4gICAgcmV0dXJuIGNvbG9ycy5tYXAoaGV4VG9SZ2IpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGV4VG9SZ2Ioc3RyKSB7XG4gICAgdmFyIHZhbCA9IFN0cmluZyhzdHIpLnJlcGxhY2UoL1teMC05YS1mXS9naSwgJycpO1xuXG4gICAgaWYgKHZhbC5sZW5ndGggPCA2KSB7XG4gICAgICAgIHZhbCA9IHZhbFswXSt2YWxbMF0rdmFsWzFdK3ZhbFsxXSt2YWxbMl0rdmFsWzJdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByOiB0b0RlY2ltYWwodmFsLnN1YnN0cmluZygwLDIpKSxcbiAgICAgIGc6IHRvRGVjaW1hbCh2YWwuc3Vic3RyaW5nKDIsNCkpLFxuICAgICAgYjogdG9EZWNpbWFsKHZhbC5zdWJzdHJpbmcoNCw2KSlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3JpZ2luKG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luID0gcHJvcChvcHRpb25zLCAnb3JpZ2luJywgT2JqZWN0KTtcbiAgICBvcmlnaW4ueCA9IHByb3Aob3JpZ2luLCAneCcsIE51bWJlcik7XG4gICAgb3JpZ2luLnkgPSBwcm9wKG9yaWdpbiwgJ3knLCBOdW1iZXIpO1xuXG4gICAgcmV0dXJuIG9yaWdpbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENhbnZhc1dpbmRvd1NpemUoY2FudmFzKSB7XG4gICAgY2FudmFzLndpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FudmFzUmVjdFNpemUoY2FudmFzKSB7XG4gICAgdmFyIHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY2FudmFzLndpZHRoID0gcmVjdC53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDYW52YXMoekluZGV4KSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICBjYW52YXMuc3R5bGUudG9wID0gJzBweCc7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gekluZGV4O1xuXG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGVsbGlwc2UoY29udGV4dCwgeCwgeSwgcmFkaXVzWCwgcmFkaXVzWSwgcm90YXRpb24sIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpQ2xvY2t3aXNlKSB7XG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY29udGV4dC5yb3RhdGUocm90YXRpb24pO1xuICAgIGNvbnRleHQuc2NhbGUocmFkaXVzWCwgcmFkaXVzWSk7XG4gICAgY29udGV4dC5hcmMoMCwgMCwgMSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGlDbG9ja3dpc2UpO1xuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFuZG9tUGh5c2ljcyhvcHRzKSB7XG4gICAgdmFyIHJhZEFuZ2xlID0gb3B0cy5hbmdsZSAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICB2YXIgcmFkU3ByZWFkID0gb3B0cy5zcHJlYWQgKiAoTWF0aC5QSSAvIDE4MCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogb3B0cy54LFxuICAgICAgeTogb3B0cy55LFxuICAgICAgd29iYmxlOiBNYXRoLnJhbmRvbSgpICogMTAsXG4gICAgICB3b2JibGVTcGVlZDogTWF0aC5taW4oMC4xMSwgTWF0aC5yYW5kb20oKSAqIDAuMSArIDAuMDUpLFxuICAgICAgdmVsb2NpdHk6IChvcHRzLnN0YXJ0VmVsb2NpdHkgKiAwLjUpICsgKE1hdGgucmFuZG9tKCkgKiBvcHRzLnN0YXJ0VmVsb2NpdHkpLFxuICAgICAgYW5nbGUyRDogLXJhZEFuZ2xlICsgKCgwLjUgKiByYWRTcHJlYWQpIC0gKE1hdGgucmFuZG9tKCkgKiByYWRTcHJlYWQpKSxcbiAgICAgIHRpbHRBbmdsZTogKE1hdGgucmFuZG9tKCkgKiAoMC43NSAtIDAuMjUpICsgMC4yNSkgKiBNYXRoLlBJLFxuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICBzaGFwZTogb3B0cy5zaGFwZSxcbiAgICAgIHRpY2s6IDAsXG4gICAgICB0b3RhbFRpY2tzOiBvcHRzLnRpY2tzLFxuICAgICAgZGVjYXk6IG9wdHMuZGVjYXksXG4gICAgICBkcmlmdDogb3B0cy5kcmlmdCxcbiAgICAgIHJhbmRvbTogTWF0aC5yYW5kb20oKSArIDIsXG4gICAgICB0aWx0U2luOiAwLFxuICAgICAgdGlsdENvczogMCxcbiAgICAgIHdvYmJsZVg6IDAsXG4gICAgICB3b2JibGVZOiAwLFxuICAgICAgZ3Jhdml0eTogb3B0cy5ncmF2aXR5ICogMyxcbiAgICAgIG92YWxTY2FsYXI6IDAuNixcbiAgICAgIHNjYWxhcjogb3B0cy5zY2FsYXIsXG4gICAgICBmbGF0OiBvcHRzLmZsYXRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRmV0dGkoY29udGV4dCwgZmV0dGkpIHtcbiAgICBmZXR0aS54ICs9IE1hdGguY29zKGZldHRpLmFuZ2xlMkQpICogZmV0dGkudmVsb2NpdHkgKyBmZXR0aS5kcmlmdDtcbiAgICBmZXR0aS55ICs9IE1hdGguc2luKGZldHRpLmFuZ2xlMkQpICogZmV0dGkudmVsb2NpdHkgKyBmZXR0aS5ncmF2aXR5O1xuICAgIGZldHRpLnZlbG9jaXR5ICo9IGZldHRpLmRlY2F5O1xuXG4gICAgaWYgKGZldHRpLmZsYXQpIHtcbiAgICAgIGZldHRpLndvYmJsZSA9IDA7XG4gICAgICBmZXR0aS53b2JibGVYID0gZmV0dGkueCArICgxMCAqIGZldHRpLnNjYWxhcik7XG4gICAgICBmZXR0aS53b2JibGVZID0gZmV0dGkueSArICgxMCAqIGZldHRpLnNjYWxhcik7XG5cbiAgICAgIGZldHRpLnRpbHRTaW4gPSAwO1xuICAgICAgZmV0dGkudGlsdENvcyA9IDA7XG4gICAgICBmZXR0aS5yYW5kb20gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBmZXR0aS53b2JibGUgKz0gZmV0dGkud29iYmxlU3BlZWQ7XG4gICAgICBmZXR0aS53b2JibGVYID0gZmV0dGkueCArICgoMTAgKiBmZXR0aS5zY2FsYXIpICogTWF0aC5jb3MoZmV0dGkud29iYmxlKSk7XG4gICAgICBmZXR0aS53b2JibGVZID0gZmV0dGkueSArICgoMTAgKiBmZXR0aS5zY2FsYXIpICogTWF0aC5zaW4oZmV0dGkud29iYmxlKSk7XG5cbiAgICAgIGZldHRpLnRpbHRBbmdsZSArPSAwLjE7XG4gICAgICBmZXR0aS50aWx0U2luID0gTWF0aC5zaW4oZmV0dGkudGlsdEFuZ2xlKTtcbiAgICAgIGZldHRpLnRpbHRDb3MgPSBNYXRoLmNvcyhmZXR0aS50aWx0QW5nbGUpO1xuICAgICAgZmV0dGkucmFuZG9tID0gTWF0aC5yYW5kb20oKSArIDI7XG4gICAgfVxuXG4gICAgdmFyIHByb2dyZXNzID0gKGZldHRpLnRpY2srKykgLyBmZXR0aS50b3RhbFRpY2tzO1xuXG4gICAgdmFyIHgxID0gZmV0dGkueCArIChmZXR0aS5yYW5kb20gKiBmZXR0aS50aWx0Q29zKTtcbiAgICB2YXIgeTEgPSBmZXR0aS55ICsgKGZldHRpLnJhbmRvbSAqIGZldHRpLnRpbHRTaW4pO1xuICAgIHZhciB4MiA9IGZldHRpLndvYmJsZVggKyAoZmV0dGkucmFuZG9tICogZmV0dGkudGlsdENvcyk7XG4gICAgdmFyIHkyID0gZmV0dGkud29iYmxlWSArIChmZXR0aS5yYW5kb20gKiBmZXR0aS50aWx0U2luKTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIGZldHRpLmNvbG9yLnIgKyAnLCAnICsgZmV0dGkuY29sb3IuZyArICcsICcgKyBmZXR0aS5jb2xvci5iICsgJywgJyArICgxIC0gcHJvZ3Jlc3MpICsgJyknO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgIGlmIChjYW5Vc2VQYXRocyAmJiBmZXR0aS5zaGFwZS50eXBlID09PSAncGF0aCcgJiYgdHlwZW9mIGZldHRpLnNoYXBlLnBhdGggPT09ICdzdHJpbmcnICYmIEFycmF5LmlzQXJyYXkoZmV0dGkuc2hhcGUubWF0cml4KSkge1xuICAgICAgY29udGV4dC5maWxsKHRyYW5zZm9ybVBhdGgyRChcbiAgICAgICAgZmV0dGkuc2hhcGUucGF0aCxcbiAgICAgICAgZmV0dGkuc2hhcGUubWF0cml4LFxuICAgICAgICBmZXR0aS54LFxuICAgICAgICBmZXR0aS55LFxuICAgICAgICBNYXRoLmFicyh4MiAtIHgxKSAqIDAuMSxcbiAgICAgICAgTWF0aC5hYnMoeTIgLSB5MSkgKiAwLjEsXG4gICAgICAgIE1hdGguUEkgLyAxMCAqIGZldHRpLndvYmJsZVxuICAgICAgKSk7XG4gICAgfSBlbHNlIGlmIChmZXR0aS5zaGFwZS50eXBlID09PSAnYml0bWFwJykge1xuICAgICAgdmFyIHJvdGF0aW9uID0gTWF0aC5QSSAvIDEwICogZmV0dGkud29iYmxlO1xuICAgICAgdmFyIHNjYWxlWCA9IE1hdGguYWJzKHgyIC0geDEpICogMC4xO1xuICAgICAgdmFyIHNjYWxlWSA9IE1hdGguYWJzKHkyIC0geTEpICogMC4xO1xuICAgICAgdmFyIHdpZHRoID0gZmV0dGkuc2hhcGUuYml0bWFwLndpZHRoICogZmV0dGkuc2NhbGFyO1xuICAgICAgdmFyIGhlaWdodCA9IGZldHRpLnNoYXBlLmJpdG1hcC5oZWlnaHQgKiBmZXR0aS5zY2FsYXI7XG5cbiAgICAgIHZhciBtYXRyaXggPSBuZXcgRE9NTWF0cml4KFtcbiAgICAgICAgTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVYLFxuICAgICAgICBNYXRoLnNpbihyb3RhdGlvbikgKiBzY2FsZVgsXG4gICAgICAgIC1NYXRoLnNpbihyb3RhdGlvbikgKiBzY2FsZVksXG4gICAgICAgIE1hdGguY29zKHJvdGF0aW9uKSAqIHNjYWxlWSxcbiAgICAgICAgZmV0dGkueCxcbiAgICAgICAgZmV0dGkueVxuICAgICAgXSk7XG5cbiAgICAgIC8vIGFwcGx5IHRoZSB0cmFuc2Zvcm0gbWF0cml4IGZyb20gdGhlIGNvbmZldHRpIHNoYXBlXG4gICAgICBtYXRyaXgubXVsdGlwbHlTZWxmKG5ldyBET01NYXRyaXgoZmV0dGkuc2hhcGUubWF0cml4KSk7XG5cbiAgICAgIHZhciBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKGJpdG1hcE1hcHBlci50cmFuc2Zvcm0oZmV0dGkuc2hhcGUuYml0bWFwKSwgJ25vLXJlcGVhdCcpO1xuICAgICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0obWF0cml4KTtcblxuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9ICgxIC0gcHJvZ3Jlc3MpO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgICAgY29udGV4dC5maWxsUmVjdChcbiAgICAgICAgZmV0dGkueCAtICh3aWR0aCAvIDIpLFxuICAgICAgICBmZXR0aS55IC0gKGhlaWdodCAvIDIpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgfSBlbHNlIGlmIChmZXR0aS5zaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgIGNvbnRleHQuZWxsaXBzZSA/XG4gICAgICAgIGNvbnRleHQuZWxsaXBzZShmZXR0aS54LCBmZXR0aS55LCBNYXRoLmFicyh4MiAtIHgxKSAqIGZldHRpLm92YWxTY2FsYXIsIE1hdGguYWJzKHkyIC0geTEpICogZmV0dGkub3ZhbFNjYWxhciwgTWF0aC5QSSAvIDEwICogZmV0dGkud29iYmxlLCAwLCAyICogTWF0aC5QSSkgOlxuICAgICAgICBlbGxpcHNlKGNvbnRleHQsIGZldHRpLngsIGZldHRpLnksIE1hdGguYWJzKHgyIC0geDEpICogZmV0dGkub3ZhbFNjYWxhciwgTWF0aC5hYnMoeTIgLSB5MSkgKiBmZXR0aS5vdmFsU2NhbGFyLCBNYXRoLlBJIC8gMTAgKiBmZXR0aS53b2JibGUsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICB9IGVsc2UgaWYgKGZldHRpLnNoYXBlID09PSAnc3RhcicpIHtcbiAgICAgIHZhciByb3QgPSBNYXRoLlBJIC8gMiAqIDM7XG4gICAgICB2YXIgaW5uZXJSYWRpdXMgPSA0ICogZmV0dGkuc2NhbGFyO1xuICAgICAgdmFyIG91dGVyUmFkaXVzID0gOCAqIGZldHRpLnNjYWxhcjtcbiAgICAgIHZhciB4ID0gZmV0dGkueDtcbiAgICAgIHZhciB5ID0gZmV0dGkueTtcbiAgICAgIHZhciBzcGlrZXMgPSA1O1xuICAgICAgdmFyIHN0ZXAgPSBNYXRoLlBJIC8gc3Bpa2VzO1xuXG4gICAgICB3aGlsZSAoc3Bpa2VzLS0pIHtcbiAgICAgICAgeCA9IGZldHRpLnggKyBNYXRoLmNvcyhyb3QpICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIHkgPSBmZXR0aS55ICsgTWF0aC5zaW4ocm90KSAqIG91dGVyUmFkaXVzO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgcm90ICs9IHN0ZXA7XG5cbiAgICAgICAgeCA9IGZldHRpLnggKyBNYXRoLmNvcyhyb3QpICogaW5uZXJSYWRpdXM7XG4gICAgICAgIHkgPSBmZXR0aS55ICsgTWF0aC5zaW4ocm90KSAqIGlubmVyUmFkaXVzO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgcm90ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKE1hdGguZmxvb3IoZmV0dGkueCksIE1hdGguZmxvb3IoZmV0dGkueSkpO1xuICAgICAgY29udGV4dC5saW5lVG8oTWF0aC5mbG9vcihmZXR0aS53b2JibGVYKSwgTWF0aC5mbG9vcih5MSkpO1xuICAgICAgY29udGV4dC5saW5lVG8oTWF0aC5mbG9vcih4MiksIE1hdGguZmxvb3IoeTIpKTtcbiAgICAgIGNvbnRleHQubGluZVRvKE1hdGguZmxvb3IoeDEpLCBNYXRoLmZsb29yKGZldHRpLndvYmJsZVkpKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgcmV0dXJuIGZldHRpLnRpY2sgPCBmZXR0aS50b3RhbFRpY2tzO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5pbWF0ZShjYW52YXMsIGZldHRpcywgcmVzaXplciwgc2l6ZSwgZG9uZSkge1xuICAgIHZhciBhbmltYXRpbmdGZXR0aXMgPSBmZXR0aXMuc2xpY2UoKTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBhbmltYXRpb25GcmFtZTtcbiAgICB2YXIgZGVzdHJveTtcblxuICAgIHZhciBwcm9tID0gcHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgZnVuY3Rpb24gb25Eb25lKCkge1xuICAgICAgICBhbmltYXRpb25GcmFtZSA9IGRlc3Ryb3kgPSBudWxsO1xuXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgYml0bWFwTWFwcGVyLmNsZWFyKCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzV29ya2VyICYmICEoc2l6ZS53aWR0aCA9PT0gd29ya2VyU2l6ZS53aWR0aCAmJiBzaXplLmhlaWdodCA9PT0gd29ya2VyU2l6ZS5oZWlnaHQpKSB7XG4gICAgICAgICAgc2l6ZS53aWR0aCA9IGNhbnZhcy53aWR0aCA9IHdvcmtlclNpemUud2lkdGg7XG4gICAgICAgICAgc2l6ZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gd29ya2VyU2l6ZS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNpemUud2lkdGggJiYgIXNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgcmVzaXplcihjYW52YXMpO1xuICAgICAgICAgIHNpemUud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgc2l6ZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXG4gICAgICAgIGFuaW1hdGluZ0ZldHRpcyA9IGFuaW1hdGluZ0ZldHRpcy5maWx0ZXIoZnVuY3Rpb24gKGZldHRpKSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZldHRpKGNvbnRleHQsIGZldHRpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGFuaW1hdGluZ0ZldHRpcy5sZW5ndGgpIHtcbiAgICAgICAgICBhbmltYXRpb25GcmFtZSA9IHJhZi5mcmFtZSh1cGRhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uRG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvbkZyYW1lID0gcmFmLmZyYW1lKHVwZGF0ZSk7XG4gICAgICBkZXN0cm95ID0gb25Eb25lO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZEZldHRpczogZnVuY3Rpb24gKGZldHRpcykge1xuICAgICAgICBhbmltYXRpbmdGZXR0aXMgPSBhbmltYXRpbmdGZXR0aXMuY29uY2F0KGZldHRpcyk7XG5cbiAgICAgICAgcmV0dXJuIHByb207XG4gICAgICB9LFxuICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICBwcm9taXNlOiBwcm9tLFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgcmFmLmNhbmNlbChhbmltYXRpb25GcmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzdHJveSkge1xuICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb25mZXR0aUNhbm5vbihjYW52YXMsIGdsb2JhbE9wdHMpIHtcbiAgICB2YXIgaXNMaWJDYW52YXMgPSAhY2FudmFzO1xuICAgIHZhciBhbGxvd1Jlc2l6ZSA9ICEhcHJvcChnbG9iYWxPcHRzIHx8IHt9LCAncmVzaXplJyk7XG4gICAgdmFyIGhhc1Jlc2l6ZUV2ZW50UmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIHZhciBnbG9iYWxEaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiA9IHByb3AoZ2xvYmFsT3B0cywgJ2Rpc2FibGVGb3JSZWR1Y2VkTW90aW9uJywgQm9vbGVhbik7XG4gICAgdmFyIHNob3VsZFVzZVdvcmtlciA9IGNhblVzZVdvcmtlciAmJiAhIXByb3AoZ2xvYmFsT3B0cyB8fCB7fSwgJ3VzZVdvcmtlcicpO1xuICAgIHZhciB3b3JrZXIgPSBzaG91bGRVc2VXb3JrZXIgPyBnZXRXb3JrZXIoKSA6IG51bGw7XG4gICAgdmFyIHJlc2l6ZXIgPSBpc0xpYkNhbnZhcyA/IHNldENhbnZhc1dpbmRvd1NpemUgOiBzZXRDYW52YXNSZWN0U2l6ZTtcbiAgICB2YXIgaW5pdGlhbGl6ZWQgPSAoY2FudmFzICYmIHdvcmtlcikgPyAhIWNhbnZhcy5fX2NvbmZldHRpX2luaXRpYWxpemVkIDogZmFsc2U7XG4gICAgdmFyIHByZWZlckxlc3NNb3Rpb24gPSB0eXBlb2YgbWF0Y2hNZWRpYSA9PT0gJ2Z1bmN0aW9uJyAmJiBtYXRjaE1lZGlhKCcocHJlZmVycy1yZWR1Y2VkLW1vdGlvbiknKS5tYXRjaGVzO1xuICAgIHZhciBhbmltYXRpb25PYmo7XG5cbiAgICBmdW5jdGlvbiBmaXJlTG9jYWwob3B0aW9ucywgc2l6ZSwgZG9uZSkge1xuICAgICAgdmFyIHBhcnRpY2xlQ291bnQgPSBwcm9wKG9wdGlvbnMsICdwYXJ0aWNsZUNvdW50Jywgb25seVBvc2l0aXZlSW50KTtcbiAgICAgIHZhciBhbmdsZSA9IHByb3Aob3B0aW9ucywgJ2FuZ2xlJywgTnVtYmVyKTtcbiAgICAgIHZhciBzcHJlYWQgPSBwcm9wKG9wdGlvbnMsICdzcHJlYWQnLCBOdW1iZXIpO1xuICAgICAgdmFyIHN0YXJ0VmVsb2NpdHkgPSBwcm9wKG9wdGlvbnMsICdzdGFydFZlbG9jaXR5JywgTnVtYmVyKTtcbiAgICAgIHZhciBkZWNheSA9IHByb3Aob3B0aW9ucywgJ2RlY2F5JywgTnVtYmVyKTtcbiAgICAgIHZhciBncmF2aXR5ID0gcHJvcChvcHRpb25zLCAnZ3Jhdml0eScsIE51bWJlcik7XG4gICAgICB2YXIgZHJpZnQgPSBwcm9wKG9wdGlvbnMsICdkcmlmdCcsIE51bWJlcik7XG4gICAgICB2YXIgY29sb3JzID0gcHJvcChvcHRpb25zLCAnY29sb3JzJywgY29sb3JzVG9SZ2IpO1xuICAgICAgdmFyIHRpY2tzID0gcHJvcChvcHRpb25zLCAndGlja3MnLCBOdW1iZXIpO1xuICAgICAgdmFyIHNoYXBlcyA9IHByb3Aob3B0aW9ucywgJ3NoYXBlcycpO1xuICAgICAgdmFyIHNjYWxhciA9IHByb3Aob3B0aW9ucywgJ3NjYWxhcicpO1xuICAgICAgdmFyIGZsYXQgPSAhIXByb3Aob3B0aW9ucywgJ2ZsYXQnKTtcbiAgICAgIHZhciBvcmlnaW4gPSBnZXRPcmlnaW4ob3B0aW9ucyk7XG5cbiAgICAgIHZhciB0ZW1wID0gcGFydGljbGVDb3VudDtcbiAgICAgIHZhciBmZXR0aXMgPSBbXTtcblxuICAgICAgdmFyIHN0YXJ0WCA9IGNhbnZhcy53aWR0aCAqIG9yaWdpbi54O1xuICAgICAgdmFyIHN0YXJ0WSA9IGNhbnZhcy5oZWlnaHQgKiBvcmlnaW4ueTtcblxuICAgICAgd2hpbGUgKHRlbXAtLSkge1xuICAgICAgICBmZXR0aXMucHVzaChcbiAgICAgICAgICByYW5kb21QaHlzaWNzKHtcbiAgICAgICAgICAgIHg6IHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IHN0YXJ0WSxcbiAgICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICAgIHNwcmVhZDogc3ByZWFkLFxuICAgICAgICAgICAgc3RhcnRWZWxvY2l0eTogc3RhcnRWZWxvY2l0eSxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcnNbdGVtcCAlIGNvbG9ycy5sZW5ndGhdLFxuICAgICAgICAgICAgc2hhcGU6IHNoYXBlc1tyYW5kb21JbnQoMCwgc2hhcGVzLmxlbmd0aCldLFxuICAgICAgICAgICAgdGlja3M6IHRpY2tzLFxuICAgICAgICAgICAgZGVjYXk6IGRlY2F5LFxuICAgICAgICAgICAgZ3Jhdml0eTogZ3Jhdml0eSxcbiAgICAgICAgICAgIGRyaWZ0OiBkcmlmdCxcbiAgICAgICAgICAgIHNjYWxhcjogc2NhbGFyLFxuICAgICAgICAgICAgZmxhdDogZmxhdFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgYSBwcmV2aW91cyBjYW52YXMgYWxyZWFkeSBhbmltYXRpbmcsXG4gICAgICAvLyBhZGQgdG8gaXRcbiAgICAgIGlmIChhbmltYXRpb25PYmopIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbk9iai5hZGRGZXR0aXMoZmV0dGlzKTtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uT2JqID0gYW5pbWF0ZShjYW52YXMsIGZldHRpcywgcmVzaXplciwgc2l6ZSAsIGRvbmUpO1xuXG4gICAgICByZXR1cm4gYW5pbWF0aW9uT2JqLnByb21pc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyZShvcHRpb25zKSB7XG4gICAgICB2YXIgZGlzYWJsZUZvclJlZHVjZWRNb3Rpb24gPSBnbG9iYWxEaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiB8fCBwcm9wKG9wdGlvbnMsICdkaXNhYmxlRm9yUmVkdWNlZE1vdGlvbicsIEJvb2xlYW4pO1xuICAgICAgdmFyIHpJbmRleCA9IHByb3Aob3B0aW9ucywgJ3pJbmRleCcsIE51bWJlcik7XG5cbiAgICAgIGlmIChkaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiAmJiBwcmVmZXJMZXNzTW90aW9uKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTGliQ2FudmFzICYmIGFuaW1hdGlvbk9iaikge1xuICAgICAgICAvLyB1c2UgZXhpc3RpbmcgY2FudmFzIGZyb20gaW4tcHJvZ3Jlc3MgYW5pbWF0aW9uXG4gICAgICAgIGNhbnZhcyA9IGFuaW1hdGlvbk9iai5jYW52YXM7XG4gICAgICB9IGVsc2UgaWYgKGlzTGliQ2FudmFzICYmICFjYW52YXMpIHtcbiAgICAgICAgLy8gY3JlYXRlIGFuZCBpbml0aWFsaXplIGEgbmV3IGNhbnZhc1xuICAgICAgICBjYW52YXMgPSBnZXRDYW52YXMoekluZGV4KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dSZXNpemUgJiYgIWluaXRpYWxpemVkKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNpemUgb2YgYSB1c2VyLXN1cHBsaWVkIGNhbnZhc1xuICAgICAgICByZXNpemVyKGNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplID0ge1xuICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIGlmICh3b3JrZXIgJiYgIWluaXRpYWxpemVkKSB7XG4gICAgICAgIHdvcmtlci5pbml0KGNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICBjYW52YXMuX19jb25mZXR0aV9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgICAgLy8gVE9ETyB0aGlzIHJlYWxseSBzaG91bGRuJ3QgYmUgaW1tZWRpYXRlLCBiZWNhdXNlIGl0IGlzIGV4cGVuc2l2ZVxuICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc0xpYkNhbnZhcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmVzaXplcihvYmopO1xuXG4gICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHJlc2l6ZToge1xuICAgICAgICAgICAgICB3aWR0aDogb2JqLndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IG9iai5oZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkb24ndCBhY3R1YWxseSBxdWVyeSB0aGUgc2l6ZSBoZXJlLCBzaW5jZSB0aGlzXG4gICAgICAgIC8vIGNhbiBleGVjdXRlIGZyZXF1ZW50bHkgYW5kIHJhcGlkbHlcbiAgICAgICAgc2l6ZS53aWR0aCA9IHNpemUuaGVpZ2h0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgYW5pbWF0aW9uT2JqID0gbnVsbDtcblxuICAgICAgICBpZiAoYWxsb3dSZXNpemUpIHtcbiAgICAgICAgICBoYXNSZXNpemVFdmVudFJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTGliQ2FudmFzICYmIGNhbnZhcykge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGNhbnZhcykpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FudmFzID0gbnVsbDtcbiAgICAgICAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd1Jlc2l6ZSAmJiAhaGFzUmVzaXplRXZlbnRSZWdpc3RlcmVkKSB7XG4gICAgICAgIGhhc1Jlc2l6ZUV2ZW50UmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgIHJldHVybiB3b3JrZXIuZmlyZShvcHRpb25zLCBzaXplLCBkb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpcmVMb2NhbChvcHRpb25zLCBzaXplLCBkb25lKTtcbiAgICB9XG5cbiAgICBmaXJlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICB3b3JrZXIucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuaW1hdGlvbk9iaikge1xuICAgICAgICBhbmltYXRpb25PYmoucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZpcmU7XG4gIH1cblxuICAvLyBNYWtlIGRlZmF1bHQgZXhwb3J0IGxhenkgdG8gZGVmZXIgd29ya2VyIGNyZWF0aW9uIHVudGlsIGNhbGxlZC5cbiAgdmFyIGRlZmF1bHRGaXJlO1xuICBmdW5jdGlvbiBnZXREZWZhdWx0RmlyZSgpIHtcbiAgICBpZiAoIWRlZmF1bHRGaXJlKSB7XG4gICAgICBkZWZhdWx0RmlyZSA9IGNvbmZldHRpQ2Fubm9uKG51bGwsIHsgdXNlV29ya2VyOiB0cnVlLCByZXNpemU6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0RmlyZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVBhdGgyRChwYXRoU3RyaW5nLCBwYXRoTWF0cml4LCB4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24pIHtcbiAgICB2YXIgcGF0aDJkID0gbmV3IFBhdGgyRChwYXRoU3RyaW5nKTtcblxuICAgIHZhciB0MSA9IG5ldyBQYXRoMkQoKTtcbiAgICB0MS5hZGRQYXRoKHBhdGgyZCwgbmV3IERPTU1hdHJpeChwYXRoTWF0cml4KSk7XG5cbiAgICB2YXIgdDIgPSBuZXcgUGF0aDJEKCk7XG4gICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ET01NYXRyaXgvRE9NTWF0cml4XG4gICAgdDIuYWRkUGF0aCh0MSwgbmV3IERPTU1hdHJpeChbXG4gICAgICBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVgsXG4gICAgICBNYXRoLnNpbihyb3RhdGlvbikgKiBzY2FsZVgsXG4gICAgICAtTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVZLFxuICAgICAgTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVZLFxuICAgICAgeCxcbiAgICAgIHlcbiAgICBdKSk7XG5cbiAgICByZXR1cm4gdDI7XG4gIH1cblxuICBmdW5jdGlvbiBzaGFwZUZyb21QYXRoKHBhdGhEYXRhKSB7XG4gICAgaWYgKCFjYW5Vc2VQYXRocykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXRoIGNvbmZldHRpIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgIH1cblxuICAgIHZhciBwYXRoLCBtYXRyaXg7XG5cbiAgICBpZiAodHlwZW9mIHBhdGhEYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgcGF0aCA9IHBhdGhEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gcGF0aERhdGEucGF0aDtcbiAgICAgIG1hdHJpeCA9IHBhdGhEYXRhLm1hdHJpeDtcbiAgICB9XG5cbiAgICB2YXIgcGF0aDJkID0gbmV3IFBhdGgyRChwYXRoKTtcbiAgICB2YXIgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciB0ZW1wQ3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgaWYgKCFtYXRyaXgpIHtcbiAgICAgIC8vIGF0dGVtcHQgdG8gZmlndXJlIG91dCB0aGUgd2lkdGggb2YgdGhlIHBhdGgsIHVwIHRvIDEwMDB4MTAwMFxuICAgICAgdmFyIG1heFNpemUgPSAxMDAwO1xuICAgICAgdmFyIG1pblggPSBtYXhTaXplO1xuICAgICAgdmFyIG1pblkgPSBtYXhTaXplO1xuICAgICAgdmFyIG1heFggPSAwO1xuICAgICAgdmFyIG1heFkgPSAwO1xuICAgICAgdmFyIHdpZHRoLCBoZWlnaHQ7XG5cbiAgICAgIC8vIGRvIHNvbWUgbGluZSBza2lwcGluZy4uLiB0aGlzIGlzIGZhc3RlciB0aGFuIGNoZWNraW5nXG4gICAgICAvLyBldmVyeSBwaXhlbCBhbmQgd2lsbCBiZSBtb3N0bHkgc3RpbGwgY29ycmVjdFxuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBtYXhTaXplOyB4ICs9IDIpIHtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBtYXhTaXplOyB5ICs9IDIpIHtcbiAgICAgICAgICBpZiAodGVtcEN0eC5pc1BvaW50SW5QYXRoKHBhdGgyZCwgeCwgeSwgJ25vbnplcm8nKSkge1xuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aWR0aCA9IG1heFggLSBtaW5YO1xuICAgICAgaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICAgIHZhciBtYXhEZXNpcmVkU2l6ZSA9IDEwO1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5taW4obWF4RGVzaXJlZFNpemUvd2lkdGgsIG1heERlc2lyZWRTaXplL2hlaWdodCk7XG5cbiAgICAgIG1hdHJpeCA9IFtcbiAgICAgICAgc2NhbGUsIDAsIDAsIHNjYWxlLFxuICAgICAgICAtTWF0aC5yb3VuZCgod2lkdGgvMikgKyBtaW5YKSAqIHNjYWxlLFxuICAgICAgICAtTWF0aC5yb3VuZCgoaGVpZ2h0LzIpICsgbWluWSkgKiBzY2FsZVxuICAgICAgXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG1hdHJpeDogbWF0cml4XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXBlRnJvbVRleHQodGV4dERhdGEpIHtcbiAgICB2YXIgdGV4dCxcbiAgICAgICAgc2NhbGFyID0gMSxcbiAgICAgICAgY29sb3IgPSAnIzAwMDAwMCcsXG4gICAgICAgIC8vIHNlZSBodHRwczovL25vbGFubGF3c29uLmNvbS8yMDIyLzA0LzA4L3RoZS1zdHJ1Z2dsZS1vZi11c2luZy1uYXRpdmUtZW1vamktb24tdGhlLXdlYi9cbiAgICAgICAgZm9udEZhbWlseSA9ICdcIkFwcGxlIENvbG9yIEVtb2ppXCIsIFwiU2Vnb2UgVUkgRW1vamlcIiwgXCJTZWdvZSBVSSBTeW1ib2xcIiwgXCJOb3RvIENvbG9yIEVtb2ppXCIsIFwiRW1vamlPbmUgQ29sb3JcIiwgXCJBbmRyb2lkIEVtb2ppXCIsIFwiVHdlbW9qaSBNb3ppbGxhXCIsIFwic3lzdGVtIGVtb2ppXCIsIHNhbnMtc2VyaWYnO1xuXG4gICAgaWYgKHR5cGVvZiB0ZXh0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRleHQgPSB0ZXh0RGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dCA9IHRleHREYXRhLnRleHQ7XG4gICAgICBzY2FsYXIgPSAnc2NhbGFyJyBpbiB0ZXh0RGF0YSA/IHRleHREYXRhLnNjYWxhciA6IHNjYWxhcjtcbiAgICAgIGZvbnRGYW1pbHkgPSAnZm9udEZhbWlseScgaW4gdGV4dERhdGEgPyB0ZXh0RGF0YS5mb250RmFtaWx5IDogZm9udEZhbWlseTtcbiAgICAgIGNvbG9yID0gJ2NvbG9yJyBpbiB0ZXh0RGF0YSA/IHRleHREYXRhLmNvbG9yIDogY29sb3I7XG4gICAgfVxuXG4gICAgLy8gYWxsIG90aGVyIGNvbmZldHRpIGFyZSAxMCBwaXhlbHMsXG4gICAgLy8gc28gdGhpcyBwaXhlbCBzaXplIGlzIHRoZSBkZS1mYWN0byAxMDAlIHNjYWxlIGNvbmZldHRpXG4gICAgdmFyIGZvbnRTaXplID0gMTAgKiBzY2FsYXI7XG4gICAgdmFyIGZvbnQgPSAnJyArIGZvbnRTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xuXG4gICAgdmFyIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoZm9udFNpemUsIGZvbnRTaXplKTtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgdmFyIHNpemUgPSBjdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5jZWlsKHNpemUuYWN0dWFsQm91bmRpbmdCb3hSaWdodCArIHNpemUuYWN0dWFsQm91bmRpbmdCb3hMZWZ0KTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5jZWlsKHNpemUuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgKyBzaXplLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCk7XG5cbiAgICB2YXIgcGFkZGluZyA9IDI7XG4gICAgdmFyIHggPSBzaXplLmFjdHVhbEJvdW5kaW5nQm94TGVmdCArIHBhZGRpbmc7XG4gICAgdmFyIHkgPSBzaXplLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICsgcGFkZGluZztcbiAgICB3aWR0aCArPSBwYWRkaW5nICsgcGFkZGluZztcbiAgICBoZWlnaHQgKz0gcGFkZGluZyArIHBhZGRpbmc7XG5cbiAgICBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5mb250ID0gZm9udDtcbiAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG5cbiAgICBjdHguZmlsbFRleHQodGV4dCwgeCwgeSk7XG5cbiAgICB2YXIgc2NhbGUgPSAxIC8gc2NhbGFyO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdiaXRtYXAnLFxuICAgICAgLy8gVE9ETyB0aGVzZSBwcm9iYWJseSBuZWVkIHRvIGJlIHRyYW5zZmVyZWQgZm9yIHdvcmtlcnNcbiAgICAgIGJpdG1hcDogY2FudmFzLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpLFxuICAgICAgbWF0cml4OiBbc2NhbGUsIDAsIDAsIHNjYWxlLCAtd2lkdGggKiBzY2FsZSAvIDIsIC1oZWlnaHQgKiBzY2FsZSAvIDJdXG4gICAgfTtcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdldERlZmF1bHRGaXJlKCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgbW9kdWxlLmV4cG9ydHMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICBnZXREZWZhdWx0RmlyZSgpLnJlc2V0KCk7XG4gIH07XG4gIG1vZHVsZS5leHBvcnRzLmNyZWF0ZSA9IGNvbmZldHRpQ2Fubm9uO1xuICBtb2R1bGUuZXhwb3J0cy5zaGFwZUZyb21QYXRoID0gc2hhcGVGcm9tUGF0aDtcbiAgbW9kdWxlLmV4cG9ydHMuc2hhcGVGcm9tVGV4dCA9IHNoYXBlRnJvbVRleHQ7XG59KChmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICByZXR1cm4gdGhpcyB8fCB7fTtcbn0pKCksIG1vZHVsZSwgZmFsc2UpKTtcblxuLy8gZW5kIHNvdXJjZSBjb250ZW50XG5cbmV4cG9ydCBkZWZhdWx0IG1vZHVsZS5leHBvcnRzO1xuZXhwb3J0IHZhciBjcmVhdGUgPSBtb2R1bGUuZXhwb3J0cy5jcmVhdGU7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwibWFpbiIsImdsb2JhbCIsImlzV29ya2VyIiwid29ya2VyU2l6ZSIsImNhblVzZVdvcmtlciIsIldvcmtlciIsIkJsb2IiLCJQcm9taXNlIiwiT2Zmc2NyZWVuQ2FudmFzIiwiT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJwcm90b3R5cGUiLCJ0cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImNhblVzZVBhdGhzIiwiUGF0aDJEIiwiRE9NTWF0cml4IiwiY2FuRHJhd0JpdG1hcCIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJmaWxsUmVjdCIsImJpdG1hcCIsInRyYW5zZmVyVG9JbWFnZUJpdG1hcCIsImNyZWF0ZVBhdHRlcm4iLCJlIiwibm9vcCIsInByb21pc2UiLCJmdW5jIiwiTW9kdWxlUHJvbWlzZSIsImV4cG9ydHMiLCJQcm9tIiwiYml0bWFwTWFwcGVyIiwic2tpcFRyYW5zZm9ybSIsIm1hcCIsInRyYW5zZm9ybSIsImhhcyIsImdldCIsIndpZHRoIiwiaGVpZ2h0IiwiZHJhd0ltYWdlIiwic2V0IiwiY2xlYXIiLCJNYXAiLCJyYWYiLCJUSU1FIiwiTWF0aCIsImZsb29yIiwiZnJhbWUiLCJjYW5jZWwiLCJmcmFtZXMiLCJsYXN0RnJhbWVUaW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjYiIsImlkIiwicmFuZG9tIiwib25GcmFtZSIsInRpbWUiLCJzZXRUaW1lb3V0IiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJnZXRXb3JrZXIiLCJ3b3JrZXIiLCJwcm9tIiwicmVzb2x2ZXMiLCJkZWNvcmF0ZSIsImV4ZWN1dGUiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJwb3N0TWVzc2FnZSIsImluaXQiLCJpbml0V29ya2VyIiwib2Zmc2NyZWVuIiwiZmlyZSIsImZpcmVXb3JrZXIiLCJzaXplIiwiZG9uZSIsInRvU3RyaW5nIiwic2xpY2UiLCJyZXNvbHZlIiwid29ya2VyRG9uZSIsIm1zZyIsImRhdGEiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImJpbmQiLCJyZXNldCIsInJlc2V0V29ya2VyIiwiY29kZSIsImpvaW4iLCJjb25zb2xlIiwid2FybiIsImRlZmF1bHRzIiwicGFydGljbGVDb3VudCIsImFuZ2xlIiwic3ByZWFkIiwic3RhcnRWZWxvY2l0eSIsImRlY2F5IiwiZ3Jhdml0eSIsImRyaWZ0IiwidGlja3MiLCJ4IiwieSIsInNoYXBlcyIsInpJbmRleCIsImNvbG9ycyIsImRpc2FibGVGb3JSZWR1Y2VkTW90aW9uIiwic2NhbGFyIiwiY29udmVydCIsInZhbCIsImlzT2siLCJ1bmRlZmluZWQiLCJwcm9wIiwibmFtZSIsIm9ubHlQb3NpdGl2ZUludCIsIm51bWJlciIsInJhbmRvbUludCIsIm1pbiIsIm1heCIsInRvRGVjaW1hbCIsInN0ciIsInBhcnNlSW50IiwiY29sb3JzVG9SZ2IiLCJoZXhUb1JnYiIsIlN0cmluZyIsInJlcGxhY2UiLCJsZW5ndGgiLCJyIiwic3Vic3RyaW5nIiwiZyIsImIiLCJnZXRPcmlnaW4iLCJvcmlnaW4iLCJPYmplY3QiLCJOdW1iZXIiLCJzZXRDYW52YXNXaW5kb3dTaXplIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInNldENhbnZhc1JlY3RTaXplIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImdldENhbnZhcyIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInBvaW50ZXJFdmVudHMiLCJlbGxpcHNlIiwiY29udGV4dCIsInJhZGl1c1giLCJyYWRpdXNZIiwicm90YXRpb24iLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJhbnRpQ2xvY2t3aXNlIiwic2F2ZSIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsInNjYWxlIiwiYXJjIiwicmVzdG9yZSIsInJhbmRvbVBoeXNpY3MiLCJvcHRzIiwicmFkQW5nbGUiLCJQSSIsInJhZFNwcmVhZCIsIndvYmJsZSIsIndvYmJsZVNwZWVkIiwidmVsb2NpdHkiLCJhbmdsZTJEIiwidGlsdEFuZ2xlIiwiY29sb3IiLCJzaGFwZSIsInRpY2siLCJ0b3RhbFRpY2tzIiwidGlsdFNpbiIsInRpbHRDb3MiLCJ3b2JibGVYIiwid29iYmxlWSIsIm92YWxTY2FsYXIiLCJmbGF0IiwidXBkYXRlRmV0dGkiLCJmZXR0aSIsImNvcyIsInNpbiIsInByb2dyZXNzIiwieDEiLCJ5MSIsIngyIiwieTIiLCJmaWxsU3R5bGUiLCJiZWdpblBhdGgiLCJ0eXBlIiwicGF0aCIsIkFycmF5IiwiaXNBcnJheSIsIm1hdHJpeCIsImZpbGwiLCJ0cmFuc2Zvcm1QYXRoMkQiLCJhYnMiLCJzY2FsZVgiLCJzY2FsZVkiLCJtdWx0aXBseVNlbGYiLCJwYXR0ZXJuIiwic2V0VHJhbnNmb3JtIiwiZ2xvYmFsQWxwaGEiLCJyb3QiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwic3Bpa2VzIiwic3RlcCIsImxpbmVUbyIsIm1vdmVUbyIsImNsb3NlUGF0aCIsImFuaW1hdGUiLCJmZXR0aXMiLCJyZXNpemVyIiwiYW5pbWF0aW5nRmV0dGlzIiwiYW5pbWF0aW9uRnJhbWUiLCJkZXN0cm95Iiwib25Eb25lIiwiY2xlYXJSZWN0IiwidXBkYXRlIiwiZmlsdGVyIiwiYWRkRmV0dGlzIiwiY29uY2F0IiwiY29uZmV0dGlDYW5ub24iLCJnbG9iYWxPcHRzIiwiaXNMaWJDYW52YXMiLCJhbGxvd1Jlc2l6ZSIsImhhc1Jlc2l6ZUV2ZW50UmVnaXN0ZXJlZCIsImdsb2JhbERpc2FibGVGb3JSZWR1Y2VkTW90aW9uIiwiQm9vbGVhbiIsInNob3VsZFVzZVdvcmtlciIsImluaXRpYWxpemVkIiwiX19jb25mZXR0aV9pbml0aWFsaXplZCIsInByZWZlckxlc3NNb3Rpb24iLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImFuaW1hdGlvbk9iaiIsImZpcmVMb2NhbCIsInRlbXAiLCJzdGFydFgiLCJzdGFydFkiLCJwdXNoIiwiYm9keSIsImFwcGVuZENoaWxkIiwib25SZXNpemUiLCJvYmoiLCJyZXNpemUiLCJjb250YWlucyIsInJlbW92ZUNoaWxkIiwiZGVmYXVsdEZpcmUiLCJnZXREZWZhdWx0RmlyZSIsInVzZVdvcmtlciIsInBhdGhTdHJpbmciLCJwYXRoTWF0cml4IiwicGF0aDJkIiwidDEiLCJhZGRQYXRoIiwidDIiLCJzaGFwZUZyb21QYXRoIiwicGF0aERhdGEiLCJFcnJvciIsInRlbXBDYW52YXMiLCJ0ZW1wQ3R4IiwibWF4U2l6ZSIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJpc1BvaW50SW5QYXRoIiwibWF4RGVzaXJlZFNpemUiLCJyb3VuZCIsInNoYXBlRnJvbVRleHQiLCJ0ZXh0RGF0YSIsInRleHQiLCJmb250RmFtaWx5IiwiZm9udFNpemUiLCJmb250IiwibWVhc3VyZVRleHQiLCJjZWlsIiwiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsImFjdHVhbEJvdW5kaW5nQm94TGVmdCIsImFjdHVhbEJvdW5kaW5nQm94QXNjZW50IiwiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwicGFkZGluZyIsImZpbGxUZXh0IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJjcmVhdGUiLCJ3aW5kb3ciLCJzZWxmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvas-confetti/dist/confetti.module.mjs\n");

/***/ })

};
;